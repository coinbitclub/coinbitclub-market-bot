const { Pool } = require('pg');
const axios = require('axios');

const pool = new Pool({
  connectionString: 'postgresql://postgres:FYHVNKLIXYmRWdRLKNnYdCXhGNsgjLSr@autorack.proxy.rlwy.net:39170/railway'
});

// Fun√ß√£o para testar o webhook diretamente
async function testWebhookReception() {
  console.log('üì° TESTANDO RECEP√á√ÉO DE WEBHOOKS:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  const testSignal = {
    symbol: 'BTCUSDT',
    action: 'BUY',
    price: 43500,
    quantity: 0.001,
    timestamp: new Date().toISOString(),
    source: 'DIAGNOSTIC_TEST'
  };
  
  try {
    const response = await axios.post(
      'https://coinbitclub-market-bot.up.railway.app/api/webhooks/signal?token=210406',
      testSignal,
      {
        timeout: 10000,
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
    
    console.log(`‚úÖ Webhook Response: ${response.status} - ${JSON.stringify(response.data)}`);
    return { success: true, data: response.data };
  } catch (error) {
    console.log(`‚ùå Webhook Error: ${error.message}`);
    if (error.response) {
      console.log(`   Status: ${error.response.status}`);
      console.log(`   Data: ${JSON.stringify(error.response.data)}`);
    }
    return { success: false, error: error.message };
  }
}

// Fun√ß√£o para verificar tabelas do banco
async function checkDatabaseTables() {
  console.log('üóÑÔ∏è VERIFICANDO ESTRUTURA DO BANCO:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  const tables = [
    'trading_signals',
    'trading_operations', 
    'market_decisions',
    'users',
    'user_trading_configs',
    'commission_history'
  ];
  
  for (const table of tables) {
    try {
      const result = await pool.query(`
        SELECT COUNT(*) as count 
        FROM information_schema.tables 
        WHERE table_name = $1
      `, [table]);
      
      if (result.rows[0].count > 0) {
        const countResult = await pool.query(`SELECT COUNT(*) as total FROM ${table}`);
        console.log(`‚úÖ ${table}: EXISTS (${countResult.rows[0].total} registros)`);
      } else {
        console.log(`‚ùå ${table}: N√ÉO EXISTE`);
      }
    } catch (error) {
      console.log(`‚ùå ${table}: ERRO - ${error.message}`);
    }
  }
  console.log('');
}

// Fun√ß√£o para verificar sinais recebidos
async function checkReceivedSignals() {
  console.log('üì® VERIFICANDO SINAIS RECEBIDOS:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    // Verificar √∫ltimos sinais
    const signalsResult = await pool.query(`
      SELECT 
        id,
        symbol,
        action,
        price,
        quantity,
        status,
        source,
        created_at,
        processed_at,
        error_message
      FROM trading_signals 
      ORDER BY created_at DESC 
      LIMIT 10
    `);
    
    if (signalsResult.rows.length > 0) {
      console.log(`üìä Encontrados ${signalsResult.rows.length} sinais recentes:`);
      signalsResult.rows.forEach((signal, index) => {
        const timestamp = new Date(signal.created_at).toLocaleString('pt-BR', {
          timeZone: 'America/Sao_Paulo'
        });
        
        let statusEmoji = '';
        switch(signal.status) {
          case 'pending': statusEmoji = '‚è≥'; break;
          case 'processing': statusEmoji = 'üîÑ'; break;
          case 'completed': statusEmoji = '‚úÖ'; break;
          case 'failed': statusEmoji = '‚ùå'; break;
          case 'rejected': statusEmoji = 'üö´'; break;
          default: statusEmoji = '‚ùì'; break;
        }
        
        console.log(`${statusEmoji} [${index + 1}] ${signal.symbol} ${signal.action} - ${timestamp}`);
        console.log(`    Pre√ßo: $${signal.price} | Qtd: ${signal.quantity} | Status: ${signal.status}`);
        console.log(`    Fonte: ${signal.source || 'N/A'}`);
        
        if (signal.processed_at) {
          const processedTime = new Date(signal.processed_at).toLocaleString('pt-BR', {
            timeZone: 'America/Sao_Paulo'
          });
          console.log(`    Processado: ${processedTime}`);
        }
        
        if (signal.error_message) {
          console.log(`    Erro: ${signal.error_message}`);
        }
        console.log('');
      });
    } else {
      console.log('‚ùå NENHUM SINAL ENCONTRADO na tabela trading_signals');
      console.log('‚ö†Ô∏è Isso indica que os sinais n√£o est√£o sendo salvos no banco!');
    }
  } catch (error) {
    console.log(`‚ùå Erro ao verificar sinais: ${error.message}`);
  }
  console.log('');
}

// Fun√ß√£o para verificar opera√ß√µes abertas
async function checkTradingOperations() {
  console.log('üíº VERIFICANDO OPERA√á√ïES DE TRADING:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    const operationsResult = await pool.query(`
      SELECT 
        id,
        user_id,
        symbol,
        action,
        entry_price,
        quantity,
        status,
        pnl,
        created_at,
        closed_at
      FROM trading_operations 
      ORDER BY created_at DESC 
      LIMIT 10
    `);
    
    if (operationsResult.rows.length > 0) {
      console.log(`üìä Encontradas ${operationsResult.rows.length} opera√ß√µes recentes:`);
      operationsResult.rows.forEach((op, index) => {
        const timestamp = new Date(op.created_at).toLocaleString('pt-BR', {
          timeZone: 'America/Sao_Paulo'
        });
        
        let statusEmoji = '';
        switch(op.status) {
          case 'open': statusEmoji = 'üîì'; break;
          case 'closed': statusEmoji = 'üîí'; break;
          case 'cancelled': statusEmoji = '‚ùå'; break;
          default: statusEmoji = '‚ùì'; break;
        }
        
        console.log(`${statusEmoji} [${index + 1}] ${op.symbol} ${op.action} - ${timestamp}`);
        console.log(`    User: ${op.user_id} | Pre√ßo: $${op.entry_price} | Qtd: ${op.quantity}`);
        console.log(`    Status: ${op.status} | PnL: ${op.pnl || 'N/A'}`);
        
        if (op.closed_at) {
          const closedTime = new Date(op.closed_at).toLocaleString('pt-BR', {
            timeZone: 'America/Sao_Paulo'
          });
          console.log(`    Fechada: ${closedTime}`);
        }
        console.log('');
      });
    } else {
      console.log('‚ùå NENHUMA OPERA√á√ÉO ENCONTRADA na tabela trading_operations');
      console.log('‚ö†Ô∏è Isso indica que as opera√ß√µes n√£o est√£o sendo criadas!');
    }
  } catch (error) {
    console.log(`‚ùå Erro ao verificar opera√ß√µes: ${error.message}`);
  }
  console.log('');
}

// Fun√ß√£o para verificar usu√°rios ativos
async function checkActiveUsers() {
  console.log('üë• VERIFICANDO USU√ÅRIOS ATIVOS:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    const usersResult = await pool.query(`
      SELECT 
        id,
        email,
        trading_active,
        balance,
        created_at
      FROM users 
      WHERE trading_active = true
      ORDER BY created_at DESC
    `);
    
    if (usersResult.rows.length > 0) {
      console.log(`üë§ ${usersResult.rows.length} usu√°rios com trading ativo:`);
      usersResult.rows.forEach((user, index) => {
        console.log(`‚úÖ [${index + 1}] ${user.email} - Saldo: $${user.balance || '0.00'}`);
      });
    } else {
      console.log('‚ùå NENHUM USU√ÅRIO COM TRADING ATIVO encontrado!');
      console.log('‚ö†Ô∏è Isso explica por que n√£o h√° opera√ß√µes sendo abertas!');
    }
    
    // Verificar total de usu√°rios
    const totalUsersResult = await pool.query('SELECT COUNT(*) as total FROM users');
    console.log(`üìä Total de usu√°rios cadastrados: ${totalUsersResult.rows[0].total}`);
    
  } catch (error) {
    console.log(`‚ùå Erro ao verificar usu√°rios: ${error.message}`);
  }
  console.log('');
}

// Fun√ß√£o para verificar configura√ß√µes de trading
async function checkTradingConfigs() {
  console.log('‚öôÔ∏è VERIFICANDO CONFIGURA√á√ïES DE TRADING:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    const configsResult = await pool.query(`
      SELECT 
        user_id,
        max_daily_operations,
        max_open_positions,
        risk_per_trade,
        auto_trading,
        allowed_symbols
      FROM user_trading_configs
    `);
    
    if (configsResult.rows.length > 0) {
      console.log(`‚öôÔ∏è ${configsResult.rows.length} configura√ß√µes de trading encontradas:`);
      configsResult.rows.forEach((config, index) => {
        console.log(`üìã [${index + 1}] User ${config.user_id}:`);
        console.log(`    Auto Trading: ${config.auto_trading ? '‚úÖ' : '‚ùå'}`);
        console.log(`    Max Opera√ß√µes/Dia: ${config.max_daily_operations || 'N/A'}`);
        console.log(`    Max Posi√ß√µes Abertas: ${config.max_open_positions || 'N/A'}`);
        console.log(`    Risco por Trade: ${config.risk_per_trade || 'N/A'}%`);
        console.log(`    S√≠mbolos Permitidos: ${config.allowed_symbols || 'TODOS'}`);
        console.log('');
      });
    } else {
      console.log('‚ùå NENHUMA CONFIGURA√á√ÉO DE TRADING encontrada!');
      console.log('‚ö†Ô∏è Usu√°rios podem n√£o ter configura√ß√£o para trading autom√°tico!');
    }
  } catch (error) {
    console.log(`‚ùå Erro ao verificar configura√ß√µes: ${error.message}`);
  }
  console.log('');
}

// Fun√ß√£o para verificar Market Intelligence
async function checkMarketIntelligence() {
  console.log('üß† VERIFICANDO MARKET INTELLIGENCE:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    const lastDecisionResult = await pool.query(`
      SELECT 
        allow_long,
        allow_short,
        confidence,
        market_pulse,
        fear_greed,
        btc_dominance,
        created_at
      FROM market_decisions 
      ORDER BY created_at DESC 
      LIMIT 1
    `);
    
    if (lastDecisionResult.rows.length > 0) {
      const decision = lastDecisionResult.rows[0];
      const timestamp = new Date(decision.created_at).toLocaleString('pt-BR', {
        timeZone: 'America/Sao_Paulo'
      });
      
      console.log(`üìä √öltima decis√£o de mercado: ${timestamp}`);
      console.log(`üîπ Market Pulse: ${parseFloat(decision.market_pulse).toFixed(1)}%`);
      console.log(`üîπ Fear & Greed: ${decision.fear_greed}`);
      console.log(`üîπ BTC Dominance: ${parseFloat(decision.btc_dominance).toFixed(1)}%`);
      console.log(`üîπ Confian√ßa: ${decision.confidence}%`);
      console.log(`üîπ Permite LONG: ${decision.allow_long ? '‚úÖ' : '‚ùå'}`);
      console.log(`üîπ Permite SHORT: ${decision.allow_short ? '‚úÖ' : '‚ùå'}`);
      
      const diffMinutes = Math.round((new Date() - new Date(decision.created_at)) / (1000 * 60));
      if (diffMinutes > 20) {
        console.log(`‚ö†Ô∏è Market Intelligence desatualizado (${diffMinutes} min atr√°s)`);
      } else {
        console.log(`‚úÖ Market Intelligence atualizado (${diffMinutes} min atr√°s)`);
      }
    } else {
      console.log('‚ùå NENHUMA DECIS√ÉO DE MERCADO encontrada!');
      console.log('‚ö†Ô∏è Market Intelligence pode n√£o estar funcionando!');
    }
  } catch (error) {
    console.log(`‚ùå Erro ao verificar Market Intelligence: ${error.message}`);
  }
  console.log('');
}

// Fun√ß√£o para simular processamento de sinal
async function simulateSignalProcessing() {
  console.log('üß™ SIMULANDO PROCESSAMENTO DE SINAL:');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  // Primeiro enviar um sinal de teste via webhook
  console.log('1Ô∏è‚É£ Enviando sinal de teste...');
  const webhookResult = await testWebhookReception();
  
  if (webhookResult.success) {
    console.log('‚úÖ Sinal enviado com sucesso via webhook');
    
    // Aguardar 5 segundos e verificar se foi processado
    console.log('‚è≥ Aguardando 5 segundos para processamento...');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Verificar se o sinal apareceu no banco
    console.log('2Ô∏è‚É£ Verificando se sinal foi salvo no banco...');
    const recentSignalResult = await pool.query(`
      SELECT * FROM trading_signals 
      WHERE source = 'DIAGNOSTIC_TEST' 
      ORDER BY created_at DESC 
      LIMIT 1
    `);
    
    if (recentSignalResult.rows.length > 0) {
      const signal = recentSignalResult.rows[0];
      console.log(`‚úÖ Sinal encontrado no banco: ID ${signal.id}, Status: ${signal.status}`);
      
      // Verificar se gerou opera√ß√£o
      console.log('3Ô∏è‚É£ Verificando se gerou opera√ß√£o de trading...');
      const operationResult = await pool.query(`
        SELECT * FROM trading_operations 
        WHERE created_at > NOW() - INTERVAL '10 minutes'
        ORDER BY created_at DESC 
        LIMIT 1
      `);
      
      if (operationResult.rows.length > 0) {
        console.log(`‚úÖ Opera√ß√£o encontrada: ${operationResult.rows[0].symbol} ${operationResult.rows[0].action}`);
      } else {
        console.log(`‚ùå NENHUMA OPERA√á√ÉO foi criada a partir do sinal!`);
        console.log('‚ö†Ô∏è Problema est√° na convers√£o de sinal para opera√ß√£o!');
      }
    } else {
      console.log('‚ùå Sinal N√ÉO foi salvo no banco!');
      console.log('‚ö†Ô∏è Problema est√° na recep√ß√£o/processamento inicial!');
    }
  } else {
    console.log('‚ùå Falha no envio do webhook de teste');
  }
  console.log('');
}

// Fun√ß√£o principal
async function investigateSignalProcessing() {
  try {
    console.log('üîç INVESTIGA√á√ÉO COMPLETA: SINAIS TRADINGVIEW ‚Üí OPERA√á√ïES\n');
    console.log(`üïê Relat√≥rio gerado em: ${new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}\n`);
    
    // 1. Verificar estrutura do banco
    await checkDatabaseTables();
    
    // 2. Verificar usu√°rios ativos
    await checkActiveUsers();
    
    // 3. Verificar configura√ß√µes de trading
    await checkTradingConfigs();
    
    // 4. Verificar Market Intelligence
    await checkMarketIntelligence();
    
    // 5. Verificar sinais recebidos
    await checkReceivedSignals();
    
    // 6. Verificar opera√ß√µes
    await checkTradingOperations();
    
    // 7. Simular processamento completo
    await simulateSignalProcessing();
    
    console.log('üéØ DIAGN√ìSTICO FINAL:');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä Com base na an√°lise acima, identifique:');
    console.log('1Ô∏è‚É£ Os webhooks est√£o chegando? (Status 200 nos logs Railway)');
    console.log('2Ô∏è‚É£ Os sinais est√£o sendo salvos na tabela trading_signals?');
    console.log('3Ô∏è‚É£ Existem usu√°rios com trading_active = true?');
    console.log('4Ô∏è‚É£ Os usu√°rios t√™m configura√ß√µes de trading v√°lidas?');
    console.log('5Ô∏è‚É£ O Market Intelligence est√° permitindo opera√ß√µes?');
    console.log('6Ô∏è‚É£ As opera√ß√µes est√£o sendo criadas na tabela trading_operations?');
    console.log('');
    console.log('üí° O gargalo estar√° no primeiro passo que falhar!');
    
  } catch (error) {
    console.error('‚ùå Erro na investiga√ß√£o:', error.message);
  } finally {
    await pool.end();
    process.exit(0);
  }
}

investigateSignalProcessing();
